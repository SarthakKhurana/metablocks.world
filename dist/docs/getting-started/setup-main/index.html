<!DOCTYPE html><html lang="en"><head><meta name="generator" content="React Static"/><link rel="preload" as="script" href="/templates/vendors~Users/shivekkhurana/WIP/Krim/eiphop.js.org/src/templates/Docs.7402d472.js"/><link rel="preload" as="script" href="/templates/Users/shivekkhurana/WIP/Krim/eiphop.js.org/src/templates/Docs.601e91c5.js"/><link rel="preload" as="script" href="/templates/styles.15542471.js"/><link rel="preload" as="script" href="/templates/vendors~main.cbf0ac03.js"/><link rel="preload" as="script" href="/main.c4b5cca9.js"/><link rel="preload" as="style" href="/styles.15542471.css"/><link rel="stylesheet" href="/styles.15542471.css"/><meta charSet="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, shrink-to-fit=no"/></head><body><div id="root"></div><script type="text/javascript">
    window.__routeInfo = JSON.parse("{\"template\":\"/Users/shivekkhurana/WIP/Krim/eiphop.js.org/src/templates/Docs\",\"sharedHashesByProp\":{},\"data\":{\"docsContent\":{\"getting-started\":{\"installation\":{\"slug\":\"installation\",\"contents\":\"<h1 id=\\\"installation\\\">Installation</h1>\\n<p>The current stable version is <code>v1.0.12</code> and is hosted on NPM package registry at <strong><a href=\\\"https://www.npmjs.com/package/eiphop\\\">https://www.npmjs.com/package/eiphop</a></strong>:</p>\\n<pre><code>$ yarn add eiphop</code></pre><p>or with npm:</p>\\n<pre><code>$ npm install eiphop --save</code></pre>\"},\"mentalModel\":{\"slug\":\"mental-model\",\"contents\":\"<h1 id=\\\"mental-model\\\">Mental Model</h1>\\n<p>The builtin <strong><a href=\\\"https://electronjs.org/docs/api/ipc-main\\\">electron IPC model</a></strong> is based on channels &amp; callbacks. You fire a request and forget about it. When the response arrives, the callback is called. This leads to multiple subscribers and providers. </p>\\n<p>With Eiphop, we restrict the number of receivers and providers to one, and create an http like interface to manage multiple requests.\\nYou define actions in the main process and call them from the renderere using the interface defined by Eiphop.</p>\\n<p><strong><a href=\\\"https://medium.com/@shivekkhurana/introducing-eiphop-an-electron-ipc-wrapper-good-fit-for-react-apps-50de6826a47e\\\">This blog post</a></strong> gives detailed explanation with diagrams and graphics. We recommend reading it to get a strong grasp of Eiphop.</p>\\n\"},\"setupRenderer\":{\"slug\":\"setup-renderer\",\"contents\":\"<h1 id=\\\"setup-renderer\\\">Setup Renderer</h1>\\n<p>To call functions defined in the <code>main</code> process, we need to setup the <code>renderer</code> to call functions and capture the return value. \\nIn your renderer\u2019s index.js file, setup the listener as follows:</p>\\n<pre><code>import {setupFrontendListener} from &#39;eiphop&#39;;\\n\\n// listen to ipc responses  \\nconst electron = window.electron; // or require(&#39;electron&#39;)\\nsetupFrontendListener(electron);</code></pre><p><code>setupFrontendListener</code> takes only an electron module. There is no support for logging on frontend (we realised it\u2019s easier to console log manually in renderer).</p>\\n<p>Now your channels are ready. All you need to do is to send requests and expect responses.</p>\\n\"},\"setupMain\":{\"slug\":\"setup-main\",\"contents\":\"<h1 id=\\\"setup-main\\\">Setup Main</h1>\\n<h2 id=\\\"define-actions\\\">Define Actions</h2>\\n<p>Actions are plain js maps where the key is the name of the action and the value is a function (sync or async).\\nAll actions recieve a <code>req</code> and a <code>res</code> object. The actions return a value by using the <code>res.send</code> function.</p>\\n<p>These actions can live in different files depending on your domain, however the keys should be unique across all actions.</p>\\n<pre><code>const pingActions = {  \\n  ping: (req, res) =&gt; {  \\n    const {payload} = req;  \\n    res.send({msg: &#39;pong&#39;});  \\n  }  \\n}\\n\\nconst hipActions = {\\n  hip: async (req, res) =&gt; {  \\n    const {payload} = req;\\n\\n    // sleep for 800ms\\n    await  new  Promise(done  =&gt;  setTimeout(done, 800)); \\n    res.send({msg: &#39;hop&#39;});\\n\\n    // or res.error({msg: &#39;failed&#39;})  \\n  } \\n}</code></pre><h2 id=\\\"setup-main-handler\\\">Setup Main Handler</h2>\\n<p>The main handler is sets up the Eiphop interface to your actions.\\nActions from different domain objects need to be combined to one global map and passed to Eiphop&#39;s <code>setupMainHandler</code> function.</p>\\n<pre><code>// somewhere inside main.js\\n\\nimport {setupMainHandler} from &#39;eiphop&#39;;\\nimport electron from &#39;electron&#39;;\\n\\nsetupMainHandler(electron, {...hipActions, ...pingActions}, true);</code></pre><p>setupMainHandler takes three arguments:</p>\\n<ol>\\n<li>The electron module to use</li>\\n<li>The actions map to expose (the above example exposes two actions : {ping: function(), hip: function()})</li>\\n<li>Enable logging flag (false by default).</li>\\n</ol>\\n\"}},\"usage\":{\"notifiers\":{\"slug\":\"notifiers\",\"contents\":\"<h1 id=\\\"notifiers\\\">Notifiers</h1>\\n<p><code>res.send</code> resolves the request but created by <code>emit</code> but sometimes you might need to send intermediate state.</p>\\n<p>For example, you might need to communicate the progress of a long upload. In casese like these, you can use the <code>res.notify</code> method to send data without terminating the cycle. </p>\\n<h2 id=\\\"notify-in-the-main\\\">Notify in the main</h2>\\n<p>Use <code>res.notify</code> method to send any arbitary data to the <code>renderer</code> process.</p>\\n<pre><code>const hipActions = {\\n  hip: async (req, res) =&gt; {  \\n    const {payload} = req;\\n\\n    // Notify renderer without terminating connection\\n    res.notify(&#39;Sleeping for 800ms, BRB&#39;);\\n\\n    // sleep for 800ms\\n    await  new  Promise(done  =&gt;  setTimeout(done, 800)); \\n    res.send({msg: &#39;hop&#39;});\\n\\n  } \\n}</code></pre><h2 id=\\\"capture-notifications-in-renderer\\\">Capture notifications in renderer</h2>\\n<p>Capture the notification data using a callback as the third argument to the <code>emit</code> function.</p>\\n<pre><code>// will log &quot;Sleeping for 800ms, BRB&quot;\\nconst onNotification = (data) =&gt; console.log(data);\\n\\nemit(&#39;hip&#39;, {empty: &#39;payload&#39;}, onNotification)  \\n  .then(res =&gt; console.log(res)) // will log {msg: &#39;hop&#39;}  \\n  .catch(err =&gt; console.log(err))  \\n;</code></pre>\"},\"requests\":{\"slug\":\"requests\",\"contents\":\"<h1 id=\\\"requests\\\">Requests</h1>\\n<p>Use the <code>emit</code> function to call actions defined in the main action map. </p>\\n<p>This functions returns a Promise, which resolves with the object returned by <code>res.send</code> in the <code>main</code> process or an error.</p>\\n<pre><code>import {emit} from &#39;eiphop&#39;;\\n\\nemit(&#39;ping&#39;, {you: &#39;can&#39;, pass: &#39;data&#39;, to: &#39;main&#39;})  \\n  .then(res =&gt; console.log(res)) // will log {msg: &#39;pong&#39;}  \\n  .catch(err =&gt; console.log(err))  \\n;\\n\\nemit(&#39;hip&#39;, {empty: &#39;payload&#39;})  \\n  .then(res =&gt; console.log(res)) // will log {msg: &#39;hop&#39;}  \\n  .catch(err =&gt; console.log(err))  \\n;</code></pre>\"}}},\"doc\":{\"slug\":\"setup-main\",\"contents\":\"<h1 id=\\\"setup-main\\\">Setup Main</h1>\\n<h2 id=\\\"define-actions\\\">Define Actions</h2>\\n<p>Actions are plain js maps where the key is the name of the action and the value is a function (sync or async).\\nAll actions recieve a <code>req</code> and a <code>res</code> object. The actions return a value by using the <code>res.send</code> function.</p>\\n<p>These actions can live in different files depending on your domain, however the keys should be unique across all actions.</p>\\n<pre><code>const pingActions = {  \\n  ping: (req, res) =&gt; {  \\n    const {payload} = req;  \\n    res.send({msg: &#39;pong&#39;});  \\n  }  \\n}\\n\\nconst hipActions = {\\n  hip: async (req, res) =&gt; {  \\n    const {payload} = req;\\n\\n    // sleep for 800ms\\n    await  new  Promise(done  =&gt;  setTimeout(done, 800)); \\n    res.send({msg: &#39;hop&#39;});\\n\\n    // or res.error({msg: &#39;failed&#39;})  \\n  } \\n}</code></pre><h2 id=\\\"setup-main-handler\\\">Setup Main Handler</h2>\\n<p>The main handler is sets up the Eiphop interface to your actions.\\nActions from different domain objects need to be combined to one global map and passed to Eiphop&#39;s <code>setupMainHandler</code> function.</p>\\n<pre><code>// somewhere inside main.js\\n\\nimport {setupMainHandler} from &#39;eiphop&#39;;\\nimport electron from &#39;electron&#39;;\\n\\nsetupMainHandler(electron, {...hipActions, ...pingActions}, true);</code></pre><p>setupMainHandler takes three arguments:</p>\\n<ol>\\n<li>The electron module to use</li>\\n<li>The actions map to expose (the above example exposes two actions : {ping: function(), hip: function()})</li>\\n<li>Enable logging flag (false by default).</li>\\n</ol>\\n\"}},\"path\":\"docs/getting-started/setup-main\",\"sharedData\":{},\"siteData\":{}}");</script><script defer="" type="text/javascript" src="/templates/vendors~Users/shivekkhurana/WIP/Krim/eiphop.js.org/src/templates/Docs.7402d472.js"></script><script defer="" type="text/javascript" src="/templates/Users/shivekkhurana/WIP/Krim/eiphop.js.org/src/templates/Docs.601e91c5.js"></script><script defer="" type="text/javascript" src="/templates/styles.15542471.js"></script><script defer="" type="text/javascript" src="/templates/vendors~main.cbf0ac03.js"></script><script defer="" type="text/javascript" src="/main.c4b5cca9.js"></script></body></html>